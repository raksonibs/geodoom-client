- We’re setting updated data from inputs directly to the model that was passed into the component, which is in conflict with the immutability patterns we mentioned. The next major releases of Ember will be all about that paradigm, so it’s best to take care of this in the present so it won’t be hard to adapt when the future hits us
- In this case though, wiring things up like this isn’t that big of a deal, because whenever we visit the dashboard.expenses.new route, the model is freshly generated and it’s obviously not used anywhere else in the application, causing no weird side effects.
- But think about editing of an already persisted record, which this component will also be used for. If we passed in a balanceChange record that’s already persisted in the store, made changes to its properties, then changed our mind and left the edit route without saving, the balanceChange record would still hold the unsaved properties, causing wrong sum calculations and possibly all sorts of weird bugs in other places where it’s bound to templates or computer properties.
- What we need here is some kind of an internal component state object with properties copied from the passed in model. All the inputs will be bound to these state properties. Save action will send these updated properties to the controller or route, where we’ll update the model with these properties and save it. For creating this state, we’ll employ the first of component’s lifecycle hooks, called init.
- There’s another important routing property you should be aware of: when dynamic segment is an object, then the model() hook for target route will not trigger.
- While routes without dynamic segments will always execute the model hook, this is not always the case when we’re passing in an object as a dynamic segment. In the upper example when we provide the balanceChange record as a dynamic segment, transition to edit route will not execute the edit route’s model hook. That means the transition will happen instantly, without querying the server for that balanceChange record.
- because the action is the same, could extract it into a mixin for save and include it in both controllers, or have a BaseBalanceChange cotnroller and extend both fromctrollers from this
- To populate dropdown menu with currencies to select from, we first need to store the currencies data. Usually we would want to use a service for keeping a state throughout the application, but since currencies are constants, we’ll put them in a module and import them wherever needed. Another reason to avoid using a service for holding currencies data is that we’ll need to use them in the user model - to get the currency symbol. Imagine we had hundreds of such records in the store, and each one had to inject that service. That would result in poor performance.
-eachin traveres pbjects properties